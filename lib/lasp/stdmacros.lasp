; Shorthand for defining macros
;
;   (defm m (form) (reverse form))
; expands to:
;   (def m (macro (form) (reverse form)))
(def defm
  (macro (name params body)
         (list 'def name
               (list 'macro params body))))

; Shorthand for defining functions
;
;   (defn f (x) (+ x 1))
; expands to:
;   (def f (fn (x) (do (+ x 1))))
(defm defn
  (name params & body)
  (list 'def name
        (list 'fn params (cons 'do body))))

; Creates local bindings.
;
; It does this by rewriting the form as a function, declaring parameters and
; instantly executing the function passing in corresponding arguments. This
; should be considered an implementation detail, let can (and should) be used
; without knowledge or regard to that it creates a function behind the scenes.

; Example:
;     (let (one 1
;           two 2)
;       (+ one two)) ; => 3
;
; expands to:
;     (apply (fn (one two) (do (+ one two))) (list 1 2))
(defm let
  (bindings & body)
  (list 'apply
        (list 'fn
              (every 2 bindings)                 ; Parameters
              (cons 'do body))
        (cons 'list (every 2 (tail bindings))))) ; Arguments

; See unevaluated form the macro expands to for debugging macros
;
; This simply uses the fact that `apply` already has this effect
; of expanding macros and makes the syntax a bit nicer, you can
; also just use `apply` directly as shown below.
;
; Example:
;     (macroexpand (defn f (x) (+ 1 x)))
;
; expands to:
;     (apply defn (quote (f (x) (+ 1 x))))
;
; which in is evaulated and returns this form:
;     (def f (fn (x) (do (+ 1 x))))
(defm macroexpand
  (form)
  (list 'apply (first form)
        (list 'quote (rest form))))
